\subsection{Build Metrics}

\subsubsection{Introduction}

Build metrics evaluate whether code generated by a Large Language Model (LLM) can successfully integrate into an industrial software repository and pass the project’s build pipelines. Unlike traditional execution-based metrics like pass@k, which only test isolated functions, build metrics capture real-world feasibility including dependencies, architectural rules, and project-specific constraints \cite{Mundhra2025IndustrialCaseStudy}.

The ASML case study introduces \textit{build@k}, a novel metric measuring the probability that at least one of the model’s generated code artifacts, called garages, successfully builds. The paper further evaluates the quality of buildable code via violations per build and critical violations per build using ASML’s TICS static-analysis system \cite{Mundhra2025IndustrialCaseStudy}.

These metrics answer a central question in software engineering evaluation for LLMs:
\begin{quote}
Can the generated code integrate, compile, and meet industrial structural standards?
\end{quote}

\subsubsection{Formula}

\textbf{Build@k} \\
\begin{quote}
“We propose a novel performance metric, termed \textit{build@k}, which draws inspiration from pass@k… A garage is considered buildable if it successfully integrates into the project and passes the build pipelines… Formula 1 formally defines the build@k metric.” \cite{Mundhra2025IndustrialCaseStudy}
\end{quote}

Build@k is defined as:

\[
\text{build@k} = \frac{1}{N} \sum_{i=1}^{N}
\begin{cases}
1 & \text{if any of the k generated code instances for } garage_i \text{ builds} \\
0 & \text{otherwise}
\end{cases}
\]

Where:
\begin{itemize}
    \item $N$ = number of tasks (garages)
    \item $k$ = number of samples per task
\end{itemize}

\textbf{Violations per Build (VPB)} \\
\begin{quote}
“We measure the \textit{average number of violations per buildable garage}…” \cite{Mundhra2025IndustrialCaseStudy}
\end{quote}

Let:
\begin{itemize}
    \item $v_i$ = number of TICS violations in buildable garage $i$
    \item $M$ = number of buildable garages
\end{itemize}

Then:

\[
\text{VPB} = \frac{1}{M} \sum_{i=1}^{M} v_i
\]

\textbf{Critical Violations per Build (Critical VPB)} \\
\begin{quote}
“Issues assigned to levels 1-7 are deemed critical… we measure the average number of critical violations (levels 1-7) per buildable garage.” \cite{Mundhra2025IndustrialCaseStudy}
\end{quote}

Let:
\begin{itemize}
    \item $cv_i$ = number of critical violations in garage $i$
\end{itemize}

Then:

\[
\text{Critical VPB} = \frac{1}{M} \sum_{i=1}^{M} cv_i
\]

\subsubsection{Variants}

\textbf{Build@k Variants}
\begin{itemize}
    \item Extends pass@k to full repository-level integration.
    \item Captures dependency correctness, code structure, and architectural alignment.
    \item Different $k$ values (e.g., 1, 5, 10) allow modeling sample efficiency and robustness.
\end{itemize}

\textbf{Violation Metric Variants} \\
TICS categories include: naming, class structure, error handling, code duplication, control flow, documentation, and safety-critical rules.

The paper distinguishes:
\begin{itemize}
    \item total violations (VPB)
    \item critical violations (Critical VPB)
\end{itemize}
Both are evaluable per build \cite{Mundhra2025IndustrialCaseStudy}.

\subsubsection{Applications in Software Engineering}

\textbf{Build@k} \\
Applied to large industrial repositories to determine whether generated code:
\begin{itemize}
    \item compiles successfully,
    \item satisfies architectural constraints,
    \item resolves dependencies,
    \item follows module and directory structure constraints,
    \item passes the complete build pipeline.
\end{itemize}

It is crucial for:
\begin{itemize}
    \item CI/CD systems,
    \item automated code generation agents,
    \item large-scale refactoring,
    \item industry-grade LLM deployment.
\end{itemize}

\textbf{Violation Metrics (VPB \& Critical VPB)} \\
Used to assess:
\begin{itemize}
    \item maintainability,
    \item structural code quality,
    \item static-analysis compliance,
    \item risk of long-term technical debt.
\end{itemize}
These reflect how clean, consistent, and robust the buildable output is \cite{Mundhra2025IndustrialCaseStudy}.

\subsubsection{Interpretation}

\textbf{High build@k} \\
Indicates:
\begin{itemize}
    \item strong LLM understanding of repository structure,
    \item consistent generation of valid, integrable code,
    \item effective alignment with industrial build constraints.
\end{itemize}

\textbf{Low build@k} \\
Indicates:
\begin{itemize}
    \item integration failures,
    \item dependency issues,
    \item architectural or structural misunderstandings.
\end{itemize}

\textbf{High VPB / High Critical VPB} \\
Indicates:
\begin{itemize}
    \item poor maintainability,
    \item violations of coding guidelines,
    \item elevated risk of bugs or build failures.
\end{itemize}

\textbf{Low VPB / Low Critical VPB} \\
Indicates:
\begin{itemize}
    \item clean, maintainable code,
    \item minimal guideline violations,
    \item low risk of future structural issues.
\end{itemize}