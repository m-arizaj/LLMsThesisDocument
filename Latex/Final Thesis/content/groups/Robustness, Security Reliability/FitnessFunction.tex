\subsection{Fitness Function Value}

A \textbf{Fitness Function Value} is the score assigned to a candidate solution in an Evolutionary Algorithm (EA), such as Genetic Programming (GP) or LLM\_GP. It is a ``problem-dependent fitness measure'' that quantifies the quality or ``Functional Performance'' of a solution (e.g., a piece of generated code).

This value is calculated by an \textit{evaluation operator}, which ``iteratively test[s] each solution and calculate[s] its fitness.'' This fitness score is then used by the \textit{selection operator} to choose which solutions will ``parent'' the next generation.

The calculation is described as a two-step process defined within the algorithm's operators:

\begin{enumerate}
    \item \textbf{Evaluation ($e$)}: A solution ($p$) is executed in an environment ($E$) to get an output ($y$).
    \begin{equation}
        y = e(p, E)
    \end{equation}
    
    \item \textbf{Fitness Measure ($\phi$)}: The fitness function measures the quality of that output ($y$) to produce the final fitness value ($f$).
    \begin{equation}
        f = \phi(y, E)
    \end{equation}
\end{enumerate}

In traditional GP, this value is strictly numeric. In LLM\_GP, the fitness could be ``numeric or expressed with natural language.''

\subsubsection*{Purpose}
The purpose of the fitness function is to ``assess the quality of the response/output'' from a candidate solution. This score provides the basis for \textbf{selection} in the evolutionary process, allowing the algorithm to differentiate between high- and low-performing solutions.


\subsubsection*{Applications}
The fitness function value is critical in guiding the evolution of code across several distinct software development applications investigated in LLM\_GP research:

\begin{itemize}
    \item \textbf{Program Synthesis and Automatic Programming}: Fitness values differentiate solutions in systems like SEIDR (Synthesize, Execute, Instruct, Debug and Rank), where generated code snippets are executed and ranked to solve benchmarks like PSB2 \cite{Hemberg2024EvolvingCodeLLM}.
    \item \textbf{Neural Architecture Search (NAS)}: Fitness functions measure the performance of evolved Python code that defines neural network architectures, facilitating the automated design of deep learning models \cite{Hemberg2024EvolvingCodeLLM}.
    \item \textbf{Reinforcement Learning (RL)}: In agent-based RL (e.g., EUREKA), the fitness function value (reward) is used to assess and evolve the code for reward functions themselves, optimizing agent controllers \cite{Hemberg2024EvolvingCodeLLM}.
    \item \textbf{Game Design}: Fitness values evaluate text or code-based descriptions of game levels (e.g., MarioGPT) and interactive collaborative design elements, distinguishing between high-quality and poor design variations \cite{Hemberg2024EvolvingCodeLLM}.
    \item \textbf{Prompt Engineering}: Fitness measures are applied to populations of text prompts (e.g., Promptbreeder) to evolve optimal instructions for LLMs by evaluating their performance on training sets \cite{Hemberg2024EvolvingCodeLLM}.
\end{itemize}

\subsubsection*{Advantages}
\begin{itemize}
    \item \textbf{Core to Evolution}: It is the fundamental mechanism that drives selection and guides the algorithm toward a better solution.
    \item \textbf{Central Comparison Point}: In traditional GP, fitness evaluations are the ``cost-dominating operator,'' making them a clear basis for comparing algorithm efficiency.
    \item \textbf{Flexible in LLM\_GP}: The concept of fitness can be expanded beyond a single numeric score to include quality assessments expressed in natural language.
\end{itemize}

\subsubsection*{Limitations}
\begin{itemize}
    \item \textbf{LLM In-Capability}: Using an LLM to \textit{calculate} the fitness value (i.e., a $\phi_{\text{LLM}}$ operator) is often not practical for problems requiring computation, as LLMs are ``notorious for not being able to compute mathematically.''
    \item \textbf{Standard Implementation}: Consequently, in many practical LLM\_GP variants, the fitness measure is one of the few operators that does \textit{not} use an LLM; instead, the code is executed externally and a traditional fitness score is calculated.
\end{itemize}



\subsubsection{Additional References}

This metric is referenced and/or used in the following paper(s):


\sloppy
\cite{
Hemberg2024EvolvingCodeLLM,
}
\fussy

